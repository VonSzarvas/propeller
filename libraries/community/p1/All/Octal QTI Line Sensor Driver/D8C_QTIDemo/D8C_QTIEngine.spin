{{///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// D8C Charge Transfer Infrared Engine//// Author: Kwabena W. Agyeman// Updated: 9/6/2010// Designed For: P8X32A// Version: 1.1//// Copyright (c) 2010 Kwabena W. Agyeman// See end of file for terms of use.//// Update History://// v1.0 - Original release - 2/28/2010.// v1.1 - Added support for variable pin assignments - 9/6/2010.//// For each included copy of this object only one spin interpreter should access it at a time.//// Nyamekye,//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Sensor Circuit:////     0   1   2   3 Pin Group////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 0,  8, 16, 24 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 1,  9, 17, 25 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 2, 10, 18, 26 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 3, 11, 19, 27 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 4, 12, 20, 28 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 5, 13, 21, 29 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 6, 14, 22, 30 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND////                    3.3V//                     |//                     --- QTI Sensor Power// Pin 7, 15, 23, 31 ----- QTI Sensor Signal//                     --- QTI Sensor Ground//                     |//                    GND///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}VAR  long cogNumber, pinGroupNumber, stack[6], sensorValues[8]PUB readSensorScaled(number) '' 8 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns a value proportional to the amount of light reflected off the surface below the QTI line sensor.'' //'' // Returns a number between 0 and 255. Where 0 is the darkest and 255 is the lightest.'' //'' // Number - The number of the line sensor to return the current value of. (0 - 7).'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (255 - (readSensorRaw(number) / (clkfreq / constant(1_000 * 255))))PUB readSensorRaw(number) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns a value proportional to the amount of light reflected off the surface below the QTI line sensor.'' //'' // Returns a number between 0 and (clkfreq / 1_000). Where (clkfreq / 1_000) is the darkest and 0 is the lightest.'' //'' // Number - The number of the line sensor to return the current value of. (0 - 7).'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (sensorValues[(number <# 7) #> 0] <# (clkfreq / 1_000))PUB QTIEngineStart(pinGroup) '' 7 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Starts up the QTI driver running on a cog.'' //'' // Returns true on success and false on failure.'' //'' // PinGroup - Pin group to use for the sensor circuit. Between 0 and 3.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  QTIEngineStop  if(chipver == 1)    pinGroupNumber := (((pinGroup <# 3) #> 0) * 8)    cogNumber := cognew(QTIDriver, @stack[0])    result or= ++cogNumberPUB QTIEngineStop '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Shuts down the QTI driver running on a cog.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if(cogNumber)    cogstop(-1 + cogNumber~)PRI QTIDriver ' 6 Stack Longs  outa := ($FF << pinGroupNumber)  frqa := 1  frqb := 1  repeat    repeat result from 0 to 3      dira := ($FF << pinGroupNumber)      waitcnt((clkfreq / 1_000) + cnt)      ctra := (constant(%0_1000 << 26) + result + pinGroupNumber)      ctrb := (constant(%0_1000 << 26) + (7 - result) + pinGroupNumber)      dira := 0      phsa := 0      phsb := 0      waitcnt((clkfreq / 1_000) + cnt)      sensorValues[result] := (((||phsa) + sensorValues[result]) >> 1)      sensorValues[7 - result] := (((||phsb) + sensorValues[7 - result]) >> 1){{/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                  TERMS OF USE: MIT License///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the// Software is furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the// Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}