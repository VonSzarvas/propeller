'This is a modified version of Parallax's Microphone2VGA sample for Sigma-Delta ADC'Now, more easily adjusted parameters'Dual ADC operation'Copyright 2007 Raymond AllenVAR  long  cog  long  nAverageA  long  nAverageB    long  par_SampleA    'current ADC value  long  par_AverageA   'average ADC value  long  par_MaximumA   'max. ADC value  long  par_MinimumA   'min. ADC value    long  par_SampleB    'current ADC value  long  par_AverageB   'average ADC value  long  par_MaximumB   'max. ADC value  long  par_MinimumB   'min. ADC value  CON' At 80MHz the sample rates are as follows:'' sample   sample               ' bits       rate               ' ----------------              ' 9       156 KHz               ' 10       78 KHz               ' 11       39 KHz               ' 12     19.5 KHz               ' 13     9.77 KHz               ' 14     4.88 KHz                                               PUB start(SampleBits, ipina, opina, nAverageWindowA, nPeakWindowA, ipinb, opinb, nAverageWindowB, nPeakWindowB) : okay'' Start ADC driver - starts a cog'' returns false if no cog available''''   SampleBits = #bits in result (see table above in CON section)''   ipinA  = PIN to use for ADC A input''   opinA  = PIN to use for ADC A output''   ipinB  = PIN to use for ADC B input''   opinB  = PIN to use for ADC B output''   nAverageWindowX =#of samples to average over''   nPeakWindowX=#of samples to take min and max of     stop  par_ipina := ipina  par_opina := opina  par_ipinb := ipinb  par_opinb := opinb  bits:=SampleBits  nAverageA:=nAverageWindowA  '#samples to average over  average_loadA:=nAverageA  peak_loadA:=nPeakWindowA  nAverageB:=nAverageWindowB  '#samples to average over  average_loadB:=nAverageB  peak_loadB:=nPeakWindowB  okay := cog := cognew(@asm_entry, @par_SampleA ) + 1PUB stop'' Stop mouse driver - frees a cog  if cog    cogstop(cog~ - 1)   PUB GetSampleA:s  return par_SampleAPUB GetAverageA:s  return (par_AverageA/nAverageA)PUB GetMaximumA:s  return par_MaximumAPUB GetMinimumA:s  return par_MinimumA    PUB GetSampleB:s  return par_SampleBPUB GetAverageB:s  return (par_AverageB/nAverageB)PUB GetMaximumB:s  return par_MaximumBPUB GetMinimumB:s  return par_MinimumB  DAT''' Assembly program'              orgasm_entry              'calculate #clock cycles to wait              SHL       asm_cycles,bits              SUB       asm_cycles,#1              'select i/o pins for ADC A  (if enabled)              CMP par_opinA,#32 wz,wc  'output pin set to 32 when disabled              IF_AE JMP #endDirA                MOV OutMask,#1              ROL OutMask,par_opinA              OR DIRA, OutMask              movs      ctra,par_ipinA                         'POS W/FEEDBACK mode for CTRA              movd      ctra,par_opinA              movi      ctra,#%01001_000              mov       frqa,#1endDirA              'select i/o pins for ADC B              CMP par_opinB,#32 wz,wc  'output pin set to 32 when disabled              IF_AE JMP #endDirB                MOV OutMask,#1              ROL OutMask,par_opinB              OR DIRA, OutMask               movs      ctrb,par_ipinB                         'POS W/FEEDBACK mode for CTRA              movd      ctrb,par_opinB              movi      ctrb,#%01001_000              mov       frqb,#1endDirB              'mov       xpos,#0                            mov       asm_cnt,cnt                     'prepare for WAITCNT loop              add       asm_cnt,asm_cycles              :loop         waitcnt   asm_cnt,asm_cycles              'wait for next CNT value (timing is determinant after WAITCNT)              mov       asm_sampleA,phsa                 'capture PHSA and get difference              sub       asm_sampleA,asm_oldA              add       asm_oldA,asm_sampleA              mov       asm_sampleB,phsb                 'capture PHSA and get difference              sub       asm_sampleB,asm_oldB              add       asm_oldB,asm_sampleB                            add       averageA,asm_sampleA              'compute average periodically so that              add       averageB,asm_sampleB                           djnz      average_cntA,#:avgsameA           'we can 0-justify samples              mov       average_cntA,average_loadA              'output current average              mov       par_x,par              add       par_x,#4*1              wrlong    averageA,par_x                            mov       averageA,#0                      'reset average for next averaging:avgsameA              djnz      average_cntB,#:avgsameB           'we can 0-justify samples              mov       average_cntB,average_loadB              'output current average              mov       par_x,par              add       par_x,#4*5              wrlong    averageB,par_x              mov       averageB,#0:avgsameB              max       peak_minA,asm_sampleA             'track min and max peaks for triggering              min       peak_maxA,asm_sampleA              max       peak_minB,asm_sampleB             'track min and max peaks for triggering              min       peak_maxB,asm_sampleB              djnz      peak_cntA,#:pksameA              mov       peak_cntA,peak_loadA              'output current min/max              mov       par_x,par              add       par_x,#4*2              wrlong    peak_maxA,par_x              add       par_x,#4              wrlong    peak_minA,par_x              mov       peak_minA,bignum                 'reset peak detectors              mov       peak_maxA,#0:pksameA              djnz      peak_cntB,#:pksameB              mov       peak_cntB,peak_loadB              'output current min/max              mov       par_x,par              add       par_x,#4*6              wrlong    peak_maxB,par_x              add       par_x,#4              wrlong    peak_minB,par_x              mov       peak_minB,bignum                 'reset peak detectors              mov       peak_maxB,#0:pksameB              'Output current sample              mov       par_x,par              wrlong    asm_sampleA,par_x              add       par_x,#4*4              wrlong    asm_sampleB,par_x                            jmp       #:loop' Data'Inputspar_x         word      0                       'working address variable for data output over hubpar_ipinA      long      32                      'Input Pinpar_opinA      long      32                      'Output Pinpar_ipinB      long      32                      'Input Pinpar_opinB      long      32                      'Output Pinbits          long      12                      '#sample bitsaverage_loadA  long      10000                   'update average every this many samples peak_loadA     long      10000                   'update peaks every this many samplesaverage_loadB  long      10000                   'update average every this many samples peak_loadB     long      10000                   'update peaks every this many samplesOutMask       long      1  asm_cycles    long      1                       'sample timeaverage_cntA   long      1peak_cntA      long      1average_cntB   long      1peak_cntB      long      1bignum        long      $FFFFFFFFasm_cnt        long       0 averageA       long       0 asm_oldA       long       0 asm_sampleA    long       0 peak_minA      long       0 peak_maxA      long       0 averageB       long       0 asm_oldB       long       0 asm_sampleB    long       0 peak_minB      long       0 peak_maxB      long       0 