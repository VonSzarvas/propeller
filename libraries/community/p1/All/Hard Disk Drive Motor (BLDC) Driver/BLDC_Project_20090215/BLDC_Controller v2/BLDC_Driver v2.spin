{ Brushless DC Motor Driver Version 2.0*************************************************** Brushless DC Motor Driver      V1.0            ** Author: Paul Rowntree / University of Guelph   ** Copyright (c) 2009                             ** See end of file for terms of use.              ***************************************************Written by Paul Rowntree, based on the Uwe Oehler's ideas for a PIC-based system- please call each of the Configure routines first, then the SetControlLevel, and finally the Start routine- call the Set and Get routines as rquired by your application}var  long  g_On, g_CycleTime, g_CoilTime, g_SetPoint, g_Phase        ' these can be manipulated in real time  long  Stack[60]                                        ' I have no idea what the minimum stack size is   long  Cog  long  EncoderPin,DrivePins[4]  long  PW_On, PW_Off, FRQ  long  Sectors_per_Coil, DriveSectors, DeadSectors, Cycles_per_Rotation  long  NextCoil, CycleSetPoint, CoilSetPoint                       ' recalculated when the g_SetPoint is setPUB ConfigureDrive( apin, bpin, cpin, tpin )    DrivePins[0] := tpin    DrivePins[1] := apin    DrivePins[2] := bpin    DrivePins[3] := cpinPUB ConfigureEncoder( TriggerPin )    EncoderPin := TriggerPinPUB ConfigureMotor( Cycles, Spokes, DeadSpokes )           ' probably 3 or 4, 6, 2 or 3    Sectors_per_Coil := Spokes    DriveSectors := Spokes-DeadSpokes    DeadSectors := DeadSpokes    Cycles_per_Rotation := Cycles       PUB SetControlLevel( Percent, SetPoint ){ the PWM power control is really a scale from 0-24; the total On+Off time is constant at 300 microseconds. }    PW_On := (Percent/4)<#24                                  ' number from 0-24    PW_Off := 25-PW_On                                        ' number from 1 to 25    g_SetPoint := (SetPoint<#200)                             ' in Hz    IF Cycles_per_Rotation ==0       Cycles_per_rotation := 4           CycleSetPoint := clkfreq/(g_SetPoint*Cycles_per_Rotation) ' in clock tics    CoilSetPoint := CycleSetPoint/3                           ' in clock ticsPUB SetPhase( N )   g_Phase := N   PUB Start_V1 : Success{ make sure that some important values are reasonably set}   IF (PW_On==0) or (g_SetPoint==0)        SetControlLevel( 60, 50 )   SetPhase( 1 )               ' this seems to work well across a wide range of speeds.  Needs more thought.   Stop   Success := (Cog := cognew( BLDC_v1, @Stack) +1 )   PUB Stop | i   If Cog      cogstop( Cog~ -1 )      repeat i from 0 to 3             ' make sure the coils are off      dira[ DrivePins[i] ]~~      outa[ DrivePins[i] ]~PUB GetOnState    result := g_OnPUB GetCycleTime    result := g_CycleTimePUB GetCoilTime    result := g_CoilTimePUB GetFreq    result := clkfreq/(Cycles_per_Rotation*g_CycleTime) pri Activate( NHigh, Pin )                      ' give a full current impulse to the chosen pin       repeat NHigh          outa[ Pin ] ~~               outa[ Pin ]~pri GentlyActivate( Nmax, Pin ) | i              ' gently ramp up the power to the pin to orient rotor       repeat i from 1 to Nmax step 50         Activate( i, Pin )         waitcnt( clkfreq/10+cnt )    Pri PositionToCoil( Coil ) | StartPulseLength,i                  ' Coil is 1,2 or 3              StartPulseLength := clkfreq/80_000                         ' 10 mS pulses seem to work       NextCoil := Coil       GentlyActivate( StartPulseLength, DrivePins[ Coil ] )        pri RunEdgeCounter(  Pin )      ' configure for positive edge detection' the optointerrupter gives a high output when a transparent section of the marker wheel is in place, and' goes low when a line is in the way.  The Schmitt trigger chip reverses this, so there should be narrow' spikes on wider backgrounds    dira[ Pin ]~     ctrb := %01010<<26+ Pin           ' Counter B is looking at the Schmitt-conditioned opto signal (inverted)    frqb := 1    phsb := 0 pri BLDC_v1 | ThePin, CycleStart, CoilStart, c ''' SPEED CONTROL : This is done just by turning off power to the coils based on the measured time to pass a coil set' or a complete A-B-C cycle.  The latter seems more stable  so far.  Uncomment the appropriate line below that' sets g_On if you want to control on the Coil time.'' To keep the timing as constant as possible, no conditionals are in the inner timing loop'    CycleStart := cnt    CoilStart := cnt        g_CycleTime := clkfreq                             ' required to bypass speed control at start    g_CoilTime := g_CycleTime/3    repeat ThePin from 0 to 3        Dira[ DrivePins[ThePin] ]~~                     ' make all pins outputs for this cog    PositionToCoil( 3 )                                ' position rotor to coil before first drive segment    waitcnt(clkfreq/2+cnt )                            ' wait 0.5 seconds to allow system to relax    RunEdgeCounter( EncoderPin )    outa[ DrivePins[ 1 ] ]~~                           ' give the A coil a full-power kick           repeat                                             ' endless operation, starting with the A coil        outa[ DrivePins[ 0 ] ]~~        c := cnt                                        ' provide a tpin signal when an A-B-C cycle starts        g_CycleTime := (g_CycleTime+c-CycleStart)/2             CycleStart := c                g_On :=  g_CycleTime>CycleSetPoint              ' power the coil IFF the current speed is too low        outa[ DrivePins[ 0 ] ]~                         ' turn off the trigger pin; as written, the tpin is high for ~50 microseconds        repeat NextCoil from 1 to 3                     ' each cycle is an A-B-C sequence            c := cnt            g_CoilTime := (g_CoilTime+c-CoilStart)/2    ' do some averaging to avoid fluctuations due to spokes                   CoilStart := c                                                       ThePin := DrivePins[ NextCoil ]            '            g_On := g_CoilTime>CoilSetPoint             ' uncomment this line OR the one near top of loop for speed control             dira[ ThePin ] := g_On                       ' disable output if we should not drive coil            repeat while phsb<DriveSectors               ' give some time off to avoid problems at high speed                    repeat PW_On                      outa[ ThePin ]~~                                       repeat PW_Off                                           outa[ ThePin ]~                             repeat while phsb<(Sectors_per_Coil-1)          ' reset Counter B when we need to start next coil            phsb  -= Sectors_per_Coil                        ' sub DriveOn to ensure that if we drive too long we dont loose our palce                                  DAT{{***********************************************************************************************************************************                                                   TERMS OF USE: MIT License                                                    *  ***********************************************************************************************************************************  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    **  files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    *  *  modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software*  *  is furnished to do so, subject to the following conditions:                                                                   *  *                                                                                                                                *  *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.*  *                                                                                                                                *  *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          *  *  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         *  *  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   *  *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         *  **********************************************************************************************************************************}}         