'' *****************************'' GPS routines''  (c) 2007 Perry James Mole''  pjm@ridge-communications.ca'' *****************************''Modified 2012 by Richard Newstead G3CWI''to work with AX25/APRS' PVH Comment - Excellent small GPS reader routines.' $GPRMC  Recommended minimum data                 ie: $GPRMC,081836,A,3751.6565,S,14507.3654,E,000.0,360.0,130998,011.3,E*62' $GPGGA  GPS Fix Data                             ie: $GPGGA,170834,4124.8963,N,08151.6838,W,1,05,1.5,280.2,M,-34.0,M,,,*75' $GPGSA  HDOP, VDOP dataCON  CR = 13                                               ' ASCII <CR>  LF = 10                                               ' ASCII <LF>    VAR     long gps_stack[100]    byte GPRMCb[68],GPGGAb[80],GPGSAb[80]      long GPRMCa[20],GPGGAa[20],GPGSAa[20]      byte gps_buff[100],Rx',cksum   long cog,cptr,ptr,arg,j   long Null[1]   OBJ uart       : "FullDuplexSerial"PUB start (Rxpin, Baud) : okay'' Starts uart object (at baud specified) in a cog'' -- returns false if no cog available  okay := uart.start(Rxpin,7,0,Baud)                                            '7 is an unused pin on SUNSET.  normally TX   return cog := cognew(readNEMA,@gps_stack) + 1PUB readNEMA  Null[0] := 0  repeat   longfill(gps_buff,20,0)   repeat while Rx <>= "$"      ' wait for the $ to ensure we are starting with     Rx := uart.rx              '   a complete NMEA sentence   cptr := 0   repeat while Rx <>= CR       '  continue to collect data until the end of the NMEA sentence      Rx := uart.rx              '  get character from Rx Buffer     if Rx == ","       gps_buff[cptr++] := 0    '  If "," replace the character with 0             /////change!//////     else       gps_buff[cptr++] := Rx   '  else save the character      if gps_buff[2] == "G"                  if gps_buff[3] == "G"                   if gps_buff[4] == "A"                       copy_buffer(@GPGGAb, @GPGGAa)   if gps_buff[2] == "R"                  if gps_buff[3] == "M"                   if gps_buff[4] == "C"                      copy_buffer(@GPRMCb, @GPRMCa)       if gps_buff[2] == "G"     if gps_buff[3] == "S"         if gps_buff[4] == "A"           copy_buffer(@GPGSAb, @GPGSAa)                pub copy_buffer ( buffer,args)         bytemove(buffer,@gps_buff,cptr) '  copy received data to buffer         ptr := buffer         arg := 0         repeat j from 0 to 78           ' build array of pointers          if byte[ptr] == 0               ' to each             if byte[ptr+1] == 0           ' record                long[args][arg] := Null     ' in              else                            ' the                long[args][arg] := ptr+1     ' data buffer             arg++          ptr++          ' now we just need to return the pointer to the desired record   pub GPSbuff  return @gps_buffpub valid   return GPRMCa[1]      pub speed   return GPRMCa[6]pub heading    return GPRMCa[7]   pub date   return GPRMCa[8]    pub GPSaltitude    return GPGGAa[8]pub time   return GPGGAa[0]pub latitude   return GPRMCa[2]    pub N_S   return GPRMCa[3]     pub longitude   return GPRMCa[4]    pub E_W   return GPRMCa[5]pub satellites   return GPGGAa[6]    pub hdop   return GPGGAa[7]   pub vdop   return GPGSAa[16] 