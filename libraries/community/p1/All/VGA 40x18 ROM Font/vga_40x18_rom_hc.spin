{{  vga_40x18_rom_hc.spin by Roger Williams  This is the helper cog for a ROM font 43 by 18 character tile  display.  The raster is drawn by a raster engine which signals  which line it is working on via the lineptr.  Two instances  of this cog pre-build lines of pixels, one working on even  lines and one on odd.}}var  long  cog0, cog1pub start(screen, pixelbuf, lineptr, userfontptr)   _screen     := screen  _pixbuf     := pixelbuf  _helpsync   := lineptr  _user_chars := userfontptr  _am_i_odd := 0  cog0 := cognew(@entry, 0) + 1  _am_i_odd := 1  cog1 := cognew(@entry, 0) + 1  return true  if cog0 == 0 or cog1 == 0    stop  else    return truepub stop  if cog0    cogstop(cog0~ - 1)  if cog1    cogstop(cog1~ - 1)pub pasm_image{  Return the location of the PASM image in case we want to re-use the RAM}  return @entrydat                        org     0entryloop                    rdword  thisline,_helpsync      'new line?                        cmp     thisline,lastline wz              if_z      jmp     #loop:newline                mov     lastline,thisline       'new line is now current line                        shr     lastline,#1 wc,nr       'get lsb in c                        test    _am_i_odd,#1 wz         'and not-amiodd in z        if_c_eq_z       jmp     #loop                   'only process this if it's our cue                        '                        add     thisline,#2             'process the next line, not the                        cmp     thisline,lines wc       'one currently being displayed              if_nc     sub     thisline,lines                        '                        'initialize pointer to 1st character of line in screen                        '                        mov     screenptr,thisline      'pixel line 0-575                        shr     screenptr,#5            'discard tile line 0-31                        shl     screenptr,#4            'text line * 40 words * 2 bytes/word                        mov     tmp,screenptr                        shl     screenptr,#2            '*(16 + 64)                        add     screenptr,tmp                        add     screenptr,_screen       'offset to _screen                                                                                'initialize line-within-tile memory pointer                        '                        mov     tileline,thisline                                   and     tileline,#%0_0001_1111      '% 00000000_00000000_00000000_000##### isolate y 0-31                        shl     tileline,#2                 'long pointer                        '                        'initialize output pointers                        '                        mov     pixbufptr,_am_i_odd wz              if_nz     mov     pixbufptr,#40*4                        add     pixbufptr,_pixbuf                        '                        mov     x,#40                   'set horizontal tiles per line                        ' Note: for the timing to work it is essential to have no more                        ' than six instructions between rdword/rdlong/wrlong in the tile loop:                        ':tile                   mov     tmp,tileline                        rdword  tile,screenptr          'read tile                        '                        ' Convert tile to pixel pattern...                        '                        ' Tile format:                        '                        ' %0000racf_hCCCCCCC                        '                        ' where c=lsbit of char code; CCCCCCC=high 7 bits                        ' h = hibit of user char code 0-511                        ' r = reverse video flag                        ' a = use alternate color flag                        ' f = 0: user font code 1: gets rotated to $8000 base of Hub Font                        '                        shl     tile,#7                 'get LSB in C and point to 32-long char                        test    tile,tile_isrombit wz   'set Z for ROM font and C for reverse                        test    tile,tile_lsbit wc      'and c for least sig. bit                        add     tmp,tile                'and line within char              if_z      shr     tmp,#1                  'user chars 16 bits high, not 32              if_z      add     tmp,_user_chars         'and offset from here                        rdlong  pixels,tmp                           if_c      shr     pixels,#1               'based on LSB, get all desired bits %%1                        test    tile,tile_isrevbit wc   'get inverse video bit              if_c      xor     pixels,loqbit                        and     pixels,loqbit           'remove unwanted interleaved char                        test    tile,tile_isaltbit wc   'get alt color bit              if_c      shl     pixels,#1               'alt color %%2                        '                        ' ...and ship the pixels to the raster cog.                        '                        wrlong  pixels,pixbufptr                        '                        add     pixbufptr,#4                        add     screenptr,#2            'point to next tile                        '                        djnz    x,#:tile                'another tile in line?                        '                        jmp     #loop                   'no, wait for next line_screen                 long    0       '@word          read-only_helpsync               long    0       '@word line currently being displayed_pixbuf                 long    0       '@2-line long pixel buffer_user_chars             long    0       'base of user defined character set_am_i_odd               long    0       '%1=process odd or even linesthisline                long    0lastline                long    0lines                   long    576     '# of pixel lines on screenlineadd                 long    $08000000loqbit                  long    %%1111_1111_1111_1111'' Note the tile is shifted left 7 bits to get the flags out of the lower' 16-bit address space before it's tested.'tile_isrombit           long    %0000_10000000_00000000tile_lsbit              long    %0010_00000000_00000000tile_isaltbit           long    %0100_00000000_00000000tile_isrevbit           long    %1000_00000000_00000000           'rptlong                 long    $7FF8'lastcnt                 long    0screenptr               res     1tileline                res     1x                       res     1pixbufptr               res     1colorbufptr             res     1tile                    res     1pixels                  res     1tmp                     res     1                        fit     $1F0                        