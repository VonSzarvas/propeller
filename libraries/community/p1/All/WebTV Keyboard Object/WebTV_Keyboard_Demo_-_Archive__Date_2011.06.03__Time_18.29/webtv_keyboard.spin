{{  WebTV Infrared Keyboard Driver  by Roger Williams  MIT License Applies (see end)  This requires a single IR receiver pin, and is coded to  assume logic 1=no IR, logic 0=IR signal present.}}{{  This version remarked three lines of code @ line 200,  elminating the compatibility with the PHILIPS keyboard,  but stablizing the RCA "ultimateTV" keyboard to 99% perfect.                                                  -Jeff-  RCA "UltimateTV" keyboard: WKN10WB1}}con  buf_len = 16  ss_caps_lock  = 1  ss_shift      = 2  ss_ctrl       = 4  ss_cmd        = 8  ss_alt        = 16  ss_fn         = 32  pre_down      = $292  pre_up        = $2BE  repeat_skip   = 10  sc_caps_lock  = $90  sc_lshift     = $8C  sc_rshift     = $4C  sc_ctrl       = $D4  sc_cmd        = $38  sc_alt        = $18  sc_fn         = $62    sc_a          = $78  sc_b          = $4  sc_c          = $48  sc_d          = $68  sc_e          = $e8  sc_f          = $64  sc_g          = $c4  sc_h          = $de  sc_i          = $ee  sc_j          = $7e  sc_k          = $6e  sc_l          = $66  sc_m          = $5e  sc_n          = $1e  sc_o          = $e6  sc_p          = $f6  sc_q          = $f8  sc_r          = $e4  sc_s          = $70  sc_t          = $84  sc_u          = $fe  sc_v          = $44  sc_w          = $f0  sc_x          = $50  sc_y          = $9e  sc_z          = $58  sc_tab        = $98  sc_return     = $5c  sc_space      = $1C  sc_left       = $12 'return $c0  sc_right      = $1a  sc_up         = $d2  sc_down       = $0a  sc_home       = $3c  sc_menu       = $2a  sc_pgup       = $6a  sc_pgdn       = $da  sc_delete     = $9c 'as backspace  sc_back       = $72 'as delete  sc_recent     = $3a  sc_esc        = $94      sc_goto       = $b4 'as f1 returns $d0  sc_save       = $f4  sc_mail       = $aa  sc_favs       = $26  sc_search     = $bc  sc_info       = $4a 'as f5    sc_tilde      = $20  sc_1          = $B8  sc_2          = $B0  sc_3          = $A8  sc_4          = $A4  sc_5          = $24  sc_6          = $3E  sc_7          = $Be  sc_8          = $Ae  sc_9          = $A6  sc_0          = $B6  sc_minus      = $36  sc_equals     = $2E  sc_left_b     = $96  sc_right_b    = $8E  sc_pipe       = $7C  sc_semicolon  = $76  sc_quote      = $D6  sc_comma      = $4E  sc_period     = $46  sc_qmark      = $16  var  byte  cog  long  baudcnt  long  halfcnt  long  mincnt  byte  IRpin  byte  buf_head  byte  buf_tail  word  buf_keys[buf_len]  long  IR_baud  long  IR_cnt_start  long  IR_cnt  word  IR_pre  word  IR_SC  byte  IR_parity    byte  key_code  byte  key_down_SC[3]  byte  repeat_hold[3]  byte  key_new  byte  ks  byte  shift_states 'ss_*  long  KeyStack[50]  pub start(pin)  baudcnt := clkfreq ** 3210488  halfcnt := clkfreq ** 1342177  mincnt := baudcnt * 3  irpin := pin  result := cog := cognew(IRkey, @KeyStack) + 1pub stop  if cog > 0    cogstop(cog - 1)    cog := 0pub Key  if buf_head <> buf_tail    result := buf_keys[buf_tail]    buf_tail := ++buf_tail & constant(buf_len - 1)pub GetKey  repeat until (result := key)pub NewKey  buf_head := buf_tail  return GetKeypub GotKey  return buf_head <> buf_tailpub BufHead  return buf_headpub BufTail  return buf_tailpub shiftstate  return shift_statespub IRkey | stcnt  repeat    'wait for start bit    repeat while ina[irpin] == 1    IR_cnt_start := cnt    'wait for end of start 3 baud start bit    repeat while ina[irpin] == 0    'make sure it's long enough    stcnt := (IR_cnt := cnt) - IR_cnt_start{    if stcnt > mincnt      baudcnt := stcnt ** $4de593d1      halfcnt := baudcnt >> 1    }      waitcnt(IR_cnt += halfcnt)       'collect preamble, $292=down $2BE=up      IR_pre := 0      repeat 10        IR_pre <<= 1        IR_pre += ina[irpin]        waitcnt(IR_cnt += baudcnt)      'collect scan code and parity      IR_parity := 0      IR_SC := 0      repeat 8        IR_SC <<= 1        IR_SC += ina[irpin]        IR_parity += ina[irpin]        waitcnt(IR_cnt += baudcnt)      'verify parity bit      if IR_parity & 1 <> ina[irpin]        'Scan code is good        process_SC       pri Process_SC  'check for shift  key_code := lookdown(IR_SC: sc_rshift, sc_ctrl, sc_cmd, sc_alt, sc_fn, sc_lshift)  if key_code > 0    'lshift to rshift    if key_code == 6      key_code := 1    'lookdown position to bit    key_code := 1 << key_code    if IR_pre == pre_down      'assert shift      shift_states |= key_code    else      'deassert shift      shift_states &= !key_code    return      'the keyboard repeats but too quickly; we impose a delay before letting  'the repeats through.  It is necessary to provide for several keys being  'down at the same time via rollover because an up code for one key might  'come after the down code for another.    if IR_pre == pre_up    if IR_SC == 0      'all keys up, clears all shifts except caps_lock      shift_states &= constant(ss_caps_lock)      repeat ks from 0 to 2        key_down_sc[ks] := 0    else              repeat ks from 0 to 2        if key_down_sc[ks] == ir_sc          key_down_sc[ks] := 0    return  'if key is not new, bump repeat_hold and bail until we make the delay.    key_new := true  repeat ks from 0 to 2    if key_down_sc[ks] == ir_sc      key_new := false      if repeat_hold[ks] < repeat_skip        repeat_hold[ks]++        return  'if key is new, add it to the repeat hold queue.      if key_new    repeat ks from 0 to 2      if key_down_sc[ks] == 0        key_down_SC[ks] := IR_SC        repeat_hold[ks] := 0        quit  if IR_SC == sc_caps_lock    'caps lock does not repeat    if key_new      shift_states ^= ss_caps_lock    return           'check for alphabet  key_code := lookdown(IR_SC: sc_a,sc_b,sc_c,sc_d,sc_e,sc_f,sc_g,sc_h,sc_i,sc_j,sc_k, {           }sc_l,sc_m,sc_n,sc_o,sc_p,sc_q,sc_r,sc_s,sc_t,sc_u,sc_v,sc_w,sc_x,sc_y,sc_z)  if key_code > 0    if shift_states & ss_ctrl      'do nothing, overrides shift    elseif shift_states & constant(ss_caps_lock | ss_shift)      key_code + =$40    else      key_code += $60    'we don't add CTRL in to letters    key_code += (shift_states & constant(!(ss_caps_lock | ss_shift | ss_ctrl)))<< 6    addkey    return  'check for single meaning key  case IR_SC    sc_tab:      key_code := $09    sc_return:      key_code := $0D    sc_space:      key_code := " "    other:       '$C0-$DF return range      key_code := lookdown(IR_SC: sc_left, sc_right, sc_up, sc_down, sc_home, sc_menu, {                 }sc_pgup, sc_pgdn, sc_delete, sc_back, sc_recent, sc_esc, $FF, $FF, $FF, $FF, {                 }sc_goto, sc_save, sc_mail, sc_favs, sc_search, sc_info)      if key_code > 0        key_code += $BF  if key_code > 0    addkeyshift    return  'check for dual meaning key  key_code := lookdown(IR_SC: sc_tilde, sc_1, sc_2, sc_3, sc_4, sc_5, sc_6, sc_7, sc_8, {             }sc_9, sc_0, sc_minus, sc_equals, sc_left_b, sc_right_b, sc_pipe, sc_semicolon, {             }sc_quote, sc_comma, sc_period, sc_qmark)  if key_code > 0    if shift_states & ss_shift == 0      'lookup unshifted      key_code := lookup(key_code: "`","1","2","3","4","5","6","7","8","9","0","-","=", {                 }"[","]","\",";","'",",",".","/")    else      'lookup shifted      key_code := lookup(key_code: "~","!","@","#","$","%","^","&","*","(",")","_","+", {                 }"{","}","|",":",34,"<",">","?")    if key_code > 0      addkeyshiftpri addkeyshift  key_code += (shift_states & constant(!(ss_caps_lock | ss_shift)))<< 6  addkey  pri addkey | nbuf  '  nbuf := (buf_head + 1) & constant(buf_len - 1)  if nbuf <> buf_tail    buf_keys[buf_head] := key_code    buf_head := nbuf        