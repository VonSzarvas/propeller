{{=========================================================================== ** C3 SPI Storage Driver **AUTHOR: Francesco de Simone, www.digimorf.comLAST MODIFIED: 08.07.2011VERSION 1.2FILENAME: Cog_C3_SPI_Driver_015_extSRAM.spinCOMMENTS: SPI bus driver        -> Init, set channel on bus, read / write data            SD support            -> Mount, unmount, send command, read sector, read PBR, read MBR          SRAM support          -> Read/WriteREQUIRES: Parallax Propeller C3 Board                 LICENSE: See end of file for terms of use=========================================================================== }}CON #1, _spiInit, _setChannel, _spiWrRd, _sdCmd, _sdMount, _sdReadSect, _sramWrRd, _loop   ' SD commands (based on SD spec names)  SD_READ_SINGLE_BLOCK  = ($40 + $11) ' reads a single block (usually a 512 byte sector) at byte address sent in command address  SD_WRITE_BLOCK        = ($40 + $18) ' write a single block (usually a 512 byte sector) at byte address sent in command address        SECTOR_SIZE           = 512         ' should always be 512 for SD cards                      BLACK = 0  WHITE = 1  GREEN = 2  RED = 3  statusLineY = 12     VAR  long command  long cog, cogon  byte DATA_buff[ SECTOR_SIZE ]        long mbr_num_sect_to_part   long pbr_bytes_per_sect  long pbr_sect_per_clust  long pbr_num_res_sect  long pbr_num_fats  long pbr_num_rt_dir_ent  long pbr_num_sec_per_fat  long first_data_sector  long first_dir_sector  long first_fat_sector  long dir_first_cluster         long dir_file_size  byte tfilename[16]  long parampointerPUB SPI_Start: okay  stop  okay := cogon := ( cog := cognew( @loop, @command )) > 0    '' driver core init  SPI_Init  SPI_Set_Channel(0)'' ----------------------------------------------------------------------------------PUB stop   if cogon~    cogstop(cog)  command~'' **********************************************************************************  '' SD CARD ROUTINES *****************************************************************'' **********************************************************************************  PUB SD_Mount(dummy0,dummy1,dummy2)|val, wait   SD_Powerup           wait := 1         setcommand( _sdMount, @dummy0 )  repeat until wait == 0    Result := val  '' ----------------------------------------------------------------------------------PUB SD_Unmount  SPI_Set_Channel(0)PUB SD_Powerup  SPI_Set_Channel( 0 )    repeat 256    SPI_Write_Read( 8, $FF, $FF)      SPI_Set_Channel( 5 )  '' ----------------------------------------------------------------------------------    PUB SD_Init | val, sec_hd  '----------------------------------------------------- MBR sector  SD_Read_Sector( 0, @DATA_buff, 0 )    sec_hd := $1BE  if DATA_buff[sec_hd] == 0    return 0  sec_hd := $1C6  mbr_num_sect_to_part := DATA_buff[sec_hd++]|(DATA_buff[sec_hd++]<<8)|(DATA_buff[sec_hd++]<<16)|(DATA_buff[sec_hd++]<<24)          '----------------------------------------------------- PBR sector  SD_Read_Sector( mbr_num_sect_to_part, @DATA_buff, 0 )    sec_hd := $0B  pbr_bytes_per_sect := DATA_buff[sec_hd++]|(DATA_buff[sec_hd++]<<8)        pbr_sect_per_clust := DATA_buff[sec_hd++]  pbr_num_res_sect   := DATA_buff[sec_hd++]|(DATA_buff[sec_hd++]<<8)      pbr_num_fats       := DATA_buff[sec_hd++]      pbr_num_rt_dir_ent := DATA_buff[sec_hd++]|(DATA_buff[sec_hd]<<8)    sec_hd := $16  pbr_num_sec_per_fat:= DATA_buff[sec_hd++]|(DATA_buff[sec_hd]<<8)  first_fat_sector  := mbr_num_sect_to_part + pbr_num_res_sect  first_dir_sector  := first_fat_sector + pbr_num_fats * pbr_num_sec_per_fat     first_data_sector := first_dir_sector + ( pbr_num_rt_dir_ent >> 4 )       return @mbr_num_sect_to_part'' ----------------------------------------------------------------------------------  PUB SD_Read_Sector( sector32no, buffer, dummy0 ) | val, wait  wait := 1         setcommand( _sdReadSect, @sector32no )    repeat until wait == 0  Result := valPUB SD_FAT_File_Close(file_handle_ptr)  if (file_handle_ptr == 0)    return ( 0 )                ' there was a problem, this was null already   long[ file_handle_ptr ][0] := 0    long[ file_handle_ptr ][1] := 0       long[ file_handle_ptr ][2] := 0  long[ file_handle_ptr ][3] := 0    return ( 1 )  '' ----------------------------------------------------------------------------------PUB SD_FAT_File_Open(filename_ptr, file_handle_ptr)|char, file_found, fnlength, findex, findex2, sector_index, dir_index, dir_entry, string_ptr1, string_ptr2   bytefill(@tfilename, " ", 11)    tfilename[11] := 0                  ' null terminate for compatibility     fnlength := strsize( filename_ptr )    repeat findex from 0 to ( fnlength - 1 )      if ( byte[filename_ptr][findex] == "." )      repeat findex2 from (findex+1) to (fnlength-1)        tfilename[(findex2 - (findex + 1)) + 8] := ToUpper(byte[filename_ptr][findex2])      quit      else      tfilename[findex] := ToUpper(byte[filename_ptr][findex])   file_found := 0  repeat sector_index from first_dir_sector to (first_dir_sector + 31)     SD_Read_Sector(sector_index, @DATA_buff, 0)        repeat dir_index from 0 to 480 step 32          if (DATA_buff[dir_index] == $00)        sector_index := first_dir_sector + 32        quit                elseif ((DATA_buff[dir_index]==$E5) or (DATA_buff[dir_index]==$2E) or (DATA_buff[dir_index+$0B]==$0F ) or (DATA_buff[dir_index+$0B]==$08))        next       if (Strncomp(@tfilename[0], @DATA_buff[dir_index], 11) == 1)        file_found := 1        dir_entry  := (( sector_index - first_dir_sector ) << 5 )+( dir_index >> 5 )         sector_index := first_dir_sector + 32        quit   if (file_found==0)        return (-1)  else    dir_index += $1A    dir_first_cluster := DATA_buff[dir_index++]|(DATA_buff[dir_index++]<<8)    dir_file_size     := DATA_buff[dir_index++]|(DATA_buff[dir_index++]<<8)|(DATA_buff[dir_index++]<<16)|(DATA_buff[dir_index++]<<24)    long[file_handle_ptr][0] := dir_first_cluster      long[file_handle_ptr][1] := dir_file_size         long[file_handle_ptr][2] := 0                 ' set file pointer current pos to first byte of file    long[file_handle_ptr][3] := dir_entry         ' the directory index of the entry        return ( dir_file_size )    '' ----------------------------------------------------------------------------------PUB SD_FAT_File_Read( file_handle_ptr, buffer_ptr, count) | fat_sector, fat_offset, bytes_read, index, sector_offset, data_sector, num_bytes_copy, next_cluster, prev_cluster, fp, fp_file_size, fp_curr_pos, fp_end_pos, fp_first_cluster, logical_sector, logical_cluster, physical_cluster, cluster_index    if (file_handle_ptr == 0)    return (0)  fp_first_cluster := long[ file_handle_ptr ][0]  fat_offset := fp_first_cluster >> 8  fat_sector := first_fat_sector + fat_offset      if ( fp_first_cluster < 2)    return (0)   fp_file_size  := long[ file_handle_ptr ][1]       fp_curr_pos   := long[ file_handle_ptr ][2]  fp_end_pos    := _Min( fp_curr_pos + count - 1, fp_file_size - 1)   count      := fp_end_pos - fp_curr_pos + 1  bytes_read := count     ' test if file pointer is at end of file (-1 or => file_size), if so simply return, user needs to seek to the start  if ( (fp_curr_pos == -1) or (fp_curr_pos => fp_file_size))    return(0)    SD_Read_Sector(fat_sector, @DATA_buff, 0)  logical_sector := fp_curr_pos / pbr_bytes_per_sect  logical_cluster := logical_sector / pbr_sect_per_clust  prev_cluster := fp_first_cluster  next_cluster := fp_first_cluster  cluster_index := 0    repeat while ( cluster_index < logical_cluster )    if ( (( prev_cluster >> 8) + first_fat_sector) <> fat_sector )      fat_offset := prev_cluster >> 8      fat_sector := first_fat_sector + fat_offset          SD_Read_Sector(fat_sector, @DATA_buff, 0)    next_cluster := word[ @DATA_buff ][ prev_cluster & $FF ]    if (next_cluster == $FFFF)      next_cluster := prev_cluster      quit    prev_cluster := next_cluster    cluster_index++  physical_cluster := next_cluster  fp := fp_curr_pos  repeat while (count > 0)    data_sector := ((fp / SECTOR_SIZE) // pbr_sect_per_clust ) + (first_data_sector + ((physical_cluster-2) * pbr_sect_per_clust) )        SD_Read_Sector(data_sector, @DATA_buff, 0)        sector_offset := fp // SECTOR_SIZE    if ( (sector_offset + count) > SECTOR_SIZE)      num_bytes_copy := (SECTOR_SIZE - sector_offset)    else      num_bytes_copy := count    bytemove( buffer_ptr, @DATA_buff + sector_offset, num_bytes_copy )    count      -= num_bytes_copy    buffer_ptr += num_bytes_copy    fp         += num_bytes_copy    if ( (fp // (pbr_bytes_per_sect * pbr_sect_per_clust))==0)      physical_cluster := word[ @DATA_buff ][ physical_cluster & $FF ]            if ( (( physical_cluster >> 8) + first_fat_sector) <> fat_sector )         fat_offset := physical_cluster >> 8        fat_sector := first_fat_sector + fat_offset            SD_Read_Sector(fat_sector, @DATA_buff, 0)  long[ file_handle_ptr ][2] := fp    return ( bytes_read )  '' **********************************************************************************  '' SRAM ROUTINES ********************************************************************'' **********************************************************************************  PUB SRAM_Init | val, ch  val := 0    ' setup bank               SPI_Set_Channel( 1 )    SRAM_Write_Read( 16, $FF, %1_01_00000_1 ) 'SPI_MODE_SEQUENTIAL    SPI_Set_Channel( 0 )        SPI_Set_Channel( 2 )    SRAM_Write_Read( 16, $FF, %1_01_00000_1 ) 'SPI_MODE_SEQUENTIAL    SPI_Set_Channel( 0 )        ' write bank    SPI_Set_Channel( 1 )          SRAM_Write_Read( 24, $FF, %10_0000000000000000 ) ' SRAM write command     SRAM_Write_Read( 8, $FF, 1 )                     ' write byte to SRAM    SPI_Set_Channel( 0 )              SPI_Set_Channel( 2 )          SRAM_Write_Read( 24, $FF, %10_0000000000000000 ) ' SRAM write command     SRAM_Write_Read( 8, $FF, 2 )                     ' write byte to SRAM    SPI_Set_Channel( 0 )    ' read bank    SPI_Set_Channel( 1 )                  SRAM_Write_Read( 24, $FF, %11_0000000000000000 ) ' SRAM read command    val := SRAM_Write_Read( 8, $FF, $FF )    SPI_Set_Channel( 0 )        SPI_Set_Channel( 2 )                  SRAM_Write_Read( 24, $FF, %11_0000000000000000 ) ' SRAM read command    val += SRAM_Write_Read( 8, $FF, $FF )    SPI_Set_Channel( 0 )  Result := val  '' ----------------------------------------------------------------------------------      PUB SRAM_Wr_block( ch, addr, num_bytes, src_buffer_ptr ) | i, c    SPI_Set_Channel( 1+ch )    SRAM_Write_Read( 24, $FF, %10_0000000000000000|addr )' SRAM write command        repeat i from 0 to num_bytes-1       SRAM_Write_Read( 8, $FF, byte[src_buffer_ptr][i] )    SPI_Set_Channel( 0 )     '' ----------------------------------------------------------------------------------   PUB SRAM_Rd_block( ch, addr, num_bytes, dest_buffer_ptr ) | i,c    SPI_Set_Channel( 1+ch )     SRAM_Write_Read( 24, $FF, %11_0000000000000000|addr ) ' SRAM read command        repeat i from 0 to num_bytes-1      byte[dest_buffer_ptr][i] := SRAM_Write_Read( 8, $FF, $FF )          SPI_Set_Channel( 0 )        '' ----------------------------------------------------------------------------------PUB SRAM_Wr_byte( ch, addr, val ) | i, c    SPI_Set_Channel( 1+ch )    SRAM_Write_Read( 24, $FF, %10_0000000000000000|addr )' SRAM write command        SRAM_Write_Read( 8, $FF, val )    SPI_Set_Channel( 0 )     '' ----------------------------------------------------------------------------------   PUB SRAM_Rd_byte( ch, addr ) | i,c    SPI_Set_Channel( 1+ch )     SRAM_Write_Read( 24, $FF, %11_0000000000000000|addr ) ' SRAM read command        c := SRAM_Write_Read( 8, $FF, $FF )          SPI_Set_Channel( 0 )        return c    '' ----------------------------------------------------------------------------------                PUB SRAM_Write_Read( num_bits, bit_mask, data_out ) | val, wait  wait := 1  setcommand( _sramWrRd, @num_bits )    repeat until wait == 0    Result := val  '' **********************************************************************************'' SPI BUS ROUTINES *****************************************************************'' **********************************************************************************     PUB SPI_Init  setcommand( _spiInit, 0 )  SPI_Set_Channel( 0 )    '' ----------------------------------------------------------------------------------PUB SPI_Set_Channel( channel )  setcommand( _setChannel, @channel )  '' ----------------------------------------------------------------------------------PUB SPI_Write_Read( num_bits, bit_mask, data_out) | val, wait  wait := 1     val := $FF      setcommand( _spiWrRd, @num_bits )   repeat until wait == 0  Result := val'' **********************************************************************************  '' UTILS ROUTINES *******************************************************************'' **********************************************************************************   PUB ToUpper(char)  if ( (char => 97) and (char =< 122))    char -= 32  return (char)  '' ----------------------------------------------------------------------------------PUB Strncomp(string_ptr1, string_ptr2, length) | index, char  repeat index from 0 to length-1    if ( ToUpper(byte[string_ptr1][index]) <> ToUpper(byte[string_ptr2][index]) )      return( 0 )                                 return( 1 )  '' ----------------------------------------------------------------------------------PUB itoa(value, sptr)  | i, z  if (value < 0)    -value          byte[ sptr++ ] := "-"  i := 1_000_000_000  z~  repeat 10    if value => i      byte[ sptr++ ] := value / i + "0"      value //= i      z~~    elseif z or i == 1      byte[ sptr++ ] := "0"    i /= 10  return (sptr)  '' ----------------------------------------------------------------------------------PUB To_ASCII(inchar, replace_char)  if (inchar < $20 or inchar > $7E)    inchar := replace_char    return(inchar)           '' ----------------------------------------------------------------------------------PUB _Min(a,b)if (a < b)  return aelse   return b  '' ----------------------------------------------------------------------------------   PUB _Max(a,b)if (a > b)  return aelse   return bPRI setcommand(cmd, argptr)  command := cmd << 16 + argptr    'write command and pointer  repeat while command             'wait for command to be cleared, signifying receiptDAT           org               loop          rdlong  tmp_ptr, par             wz        if_z  jmp     #loop              movd    :arg, #arg0                       mov     tmp_ptr_1, tmp_ptr                mov     params_no, #3       :arg          rdlong  arg0, tmp_ptr_1              add     :arg, d0              add     tmp_ptr_1, #4              djnz    params_no, #:arg              mov     global_params, tmp_ptr                                                        wrlong  zero,par                            ror     tmp_ptr, #16+2                    add     tmp_ptr, #jumps              movs    :table, tmp_ptr              rol     tmp_ptr, #2              shl     tmp_ptr, #3:table        mov     tmp_ptr_1, 0              shr     tmp_ptr_1, tmp_ptr              and     tmp_ptr_1, #$FF              jmpret  ret_loc, tmp_ptr_1            jumps         byte   $0                              byte   _spi_init              byte   _spi_set_ch                                byte   _spi_wr_rd              byte   _sd_cmd              byte   _sd_mount              byte   _sd_rd_sct              byte   _sram_wr_rd                    NotUsed_      jmp     #loop' used variables -----tmp_ptr_1     long   0params_no     long   0ret_loc       long   0d0            long   $200'-------------------------------------------------------------------- '  exitresult, input: resultValue, resultTime output: nothing'-------------------------------------------------------------------- exitresult    mov    tmp_ptr_2, global_params                            add    tmp_ptr_2, #12                                   wrlong resultValue, tmp_ptr_2                                       add    tmp_ptr_2, #4                                    wrlong zero, tmp_ptr_2                                                                     exitresult_ret              ret              ' used variables -----   zero          long   0tmp_ptr_2     long   0'-------------------------------------------------------------------- '  _sd_mount, input: nothing, output: nothing'--------------------------------------------------------------------_sd_mount     mov   sdCmd, _SD_GO_IDLE_STATE            ' prepare CMD0 ( go to idle state )                                                                                    mov   sdAttempts1, _SD_RESPONSE_LIMIT     ' prepare a limited number of attempts                         mov   sdResponse1, #$FF                   ' set sdresponse1 to default error code $FF              mov   sdAddress, #0                       ' reset address for sd command  :SDidleState1Loop              call  #_sendSDCmd                         ' send command to SD and back result in sdResponse1              cmp   sdResponse1, #1          wz         ' check response1         if_z jmp   #idleOK                             ' if == 1 SD card is in idle state        if_nz djnz  sdAttempts1, #:SDidleState1Loop     ' else decrement attempts and check if run out of them              mov   sdResponse1, #$10              jmp   #_exit2                             ' setup exit result              '--------------------------------------------------------------------idleOK        mov   sdCmd, _SD_EXIT_IDLE_STATE          ' prepare CMD1 ( exit from idle state and prepare )              mov   sdAttempts1, _SD_RESPONSE_LIMIT     ' prepare a limited number of attempts              mov   sdResponse1, #$FF                   ' set sdresponse1 to default error code $FFSDidleState2Loop               call  #_sendSDCmd                         ' send command to SD and back result in sdResponse1              cmp   sdResponse1, #0          wz         ' check sdResponse1              if_z jmp   #idleExitOK                         ' if sdResponse1 == 0 SD exit from idle and is ready, go on        if_nz djnz  sdAttempts1, #SDidleState2Loop      ' else go on with attempts and check if run out of them              mov   sdResponse1, #$11                   ' setup exit result                                   jmp   #_exit2              '---------------------------------------------------------------------idleExitOK    mov   sdCmd, _SD_APP_CMD                  ' prepare CMD55 ( check if a command is for SD card and not MMC )                call  #_sendSDCmd                         ' send command to SD and back result in sdResponse1              tjz   sdResponse1,#appCmdOK               ' if sdResponse1 == 0 go on else exit with error              mov   sdResponse1, #$12               jmp   #_exit2              '--------------------------------------------------------------------  appCmdOK      mov   sdCmd, _SD_SEND_OP_CMD              ' prepare CMD41 ( check if a command is for SD card and not MMC )              mov   sdAddress, #0                call  #_sendSDCmd                         ' send command to SD and back result in sdResponse1              tjz   sdResponse1, #_exit2                ' if sdResponse1 == 0 go on else exit with error              mov   sdResponse1, #$13               jmp   #_exit2                                                        ' setup exit result '--------------------------------------------------------------------_exit2        mov   resultValue, sdResponse1            ' copy sdResponse1 to a resultValue for SPIN              call  #exitresult                         ' return result  _sd_mount_ret ret' used variables -----  bit_cycle     long  0                                   ' back to driver command parse loopdummy_cycle   long  0'-------------------------------------------------------------------- '  _sd_cmd, input: command, output: result'-------------------------------------------------------------------- _sd_cmd       mov   sdCmd, arg0              call  #_sendSDCmd              mov   resultValue, sdResponse1            ' copy sdResponse1 to a resultValue for SPIN              call  #exitresult_sd_cmd_ret   ret'-------------------------------------------------------------------- '  _setSDCommand, input: command, output: result'-------------------------------------------------------------------- _sendSDCmd    mov   arg0, #8                            ' set 8 bit for standard command to SD              mov   arg1, #$FF                          ' set a byte mask for results              mov   arg2, sdCmd                         ' use the command value on arg2 for SPI read write routine                                    call  #_spi_wr_rd                         ' send command data to spi bus                            mov   adr_bytes, #4                       ' prepare 4 byte cycle for the 32 bit address:sendAddress  rol   sdAddress, #8                       ' take the most high byte              mov   arg2, sdAddress                                    and   arg2, #$FF                          ' take the first byte              call  #_spi_wr_rd                         ' send address data byte              djnz  adr_bytes, #:sendAddress            ' go on with other bytes left                                                                       mov   arg2, #$95                          ' prepare CRC, this is used only for init operation              call  #_spi_wr_rd                         ' send CRC byte              mov   sdAttempts2, _SD_RESPONSE_LIMIT     ' prepare attempts for receiving result of the command              mov   arg2, #$FF              mov   sdResponse1, #$FF                                               :SDcmdResp    call  #_spi_wr_rd              cmp   resultValue, #$FF       wz          ' check if it's valid ( != $FF )                                                   if_nz mov   sdResponse1, resultValue            ' data is valid, backup the result in sdresponse        if_nz call  #_spi_wr_rd              if_nz jmp   #_sendSDCmd_ret                     ' go back              djnz  sdAttempts2, #:SDcmdResp            ' go on with attempts              mov   sdResponse1, #$FF                   ' return error ( $FF ) if nothing has been done  _sendSDCmd_ret              ret              ' used variables -----   sdCmd         long   0sdAddress     long   0adr_bytes     long   0                                             sdAttempts1   long   0sdResponse1   long   0sdAttempts2   long   0sdResponse2   long   0'-------------------------------------------------------------------- '  _sd_rd_sct, input: sector number, buffer pointer  output: buffer filled'--------------------------------------------------------------------_sd_rd_sct    mov   sdCmd, _SD_READ_SINGLE_BLOCK        ' prepare CMD17 ( read single block )                                                                                                                                                    mov   sdResponse1, #$FF                    ' set sdresponse1 to default error code $FF                mov   sdAddress, arg0                     ' reset address for sd command              shl   sdAddress, _SECTOR_SIZE             ' address * _SECTOR_SIZE ( 512 bytes )              mov   sectBuffer, arg1SDidleState1Loop              call  #_sendSDCmd                         ' send command to SD and back result in sdResponse1              tjz   sdResponse1, #RdBlockOK             ' check response1                                                    mov   sdResponse1, #$14              jmp   #_exit1                             ' setup exit result '--------------------------------------------------------------------  RdBlockOK     mov   attempt_cycle, _SD_RETRIEVE_SECTOR_LIMIT              mov   arg0, #8                            ' set 8 bit for standard command to SD              mov   arg1, #$FF                          ' set a byte mask for results              mov   arg2, #$FF                          ' use the command value on arg2 for SPI read write routine                                 loopSectorLimit                                                        call #_spi_wr_rd                          ' receive data to spi bus              cmp   resultvalue, #$FE        wz         if_z jmp   #readDataBytes              djnz  attempt_cycle, #loopSectorLimit              mov   sdResponse1, #$15              jmp   #_exit1                             ' setup exit result'--------------------------------------------------------------------readDataBytes mov   attempt_cycle, #1                   ' set the maximum iteration for the read byte loop              shl   attempt_cycle, _SECTOR_SIZE                            mov   tmp_ptr_3, sectBuffer               ' backup of the buffer pointer                            mov   arg0, #8                            ' set 8 bit for standard command to SD              mov   arg1, #$FF                          ' set a byte mask for results              mov   arg2, #$FF                          ' use the command value on arg2 for SPI read write routine  readSDByteLoop               call  #_spi_wr_rd                         ' receive command data to spi bus              wrbyte  resultValue, tmp_ptr_3              add   tmp_ptr_3, #1              djnz  attempt_cycle, #readSDByteLoop                            call #_spi_wr_rd                          ' ignore this data              call #_spi_wr_rd                          ' ignore CRC value              call #_spi_wr_rd                          ' finally 8 more clocks for the card to finish                            mov   sdResponse1, #0               _exit1        mov   resultValue, sdResponse1            ' copy sdResponse1 to a resultValue for SPIN              call  #exitresult                         ' return result_sd_rd_sct_ret              ret              ' used variables -----attempt_cycle long   0tmp_ptr_3     long   0'-------------------------------------------------------------------- '  _spi_init, input: nothing, output: nothing'-------------------------------------------------------------------- _spi_init     mov    dira, _SPI_SRAM_DIR_CFG              mov    outa, #0              and    outa, _SPI_SEL_CLR_MASK              or     outa, _SPI_SEL_CLR              _spi_init_ret ret'-------------------------------------------------------------------- '  _spi_set_ch, input: arg0 ( channel no ), output: nothing'-------------------------------------------------------------------- _spi_set_ch   mov    _channel, arg0              and    outa, _SPI_SEL_CLR_MASK           ' send clr pulse to the counter              or     outa, _SPI_SEL_CLR                            cmp    _channel, #0              wz         if_z jmp    #_spi_set_ch_ret                  ' if channel is 0 then go back                            mov    ch_cycle, _channelloopchannel   or     outa, _SPI_SEL_CLK                ' sent spi clock cycles as much as the channel number              and    outa, _SPI_SEL_CLK_MASK              djnz   ch_cycle, #loopChannel                    _spi_set_ch_ret              ret              ' used variables -----   _channel      long   0  ' channel setup variablech_cycle      long   0                                  '-------------------------------------------------------------------- '  _sram_wr_rd, Input: _bits, _mask, _out   Output: resultValue'--------------------------------------------------------------------_sram_wr_rd   call   #_spi_wr_rd              call   #exitresult _sram_wr_rd_ret              ret               '-------------------------------------------------------------------- '  _spiWrRd, Input: _bits, _mask, _out   Output: resultValue'--------------------------------------------------------------------_spi_wr_rd    mov   _bits, arg0                            mov   _mask, arg1                            mov   _out,  arg2                                              ror   _out, _bits                                                        ' Prepare data                                           bitLoop       rol   _out, #1               wc           ' Prepare data on out port              muxc  outa, _SPI_MOSI                                    or    outa, _SPI_SCK                      ' Raise clock              test  _SPI_MISO, ina         wc           ' Retrieve data from in port                     rcl   resultValue, #1                                    and   outa, _SPI_SCK_MASK                 ' Drop clock                                                               djnz  _bits, #bitLoop                                                                                                                                                                                                          close         and   resultValue, _mask                 ' Mask resulting value              and   outa, _SPI_SCK_MASK                ' close signals for Clock              and   outa, _SPI_MOSI_MASK               ' close signals for MOSI_spi_wr_rd_ret              ret              ' used variables -----   _bits         long    0_out          long    0_mask         long    0                                                                                                                                                           '-------------------------------------------------------------------- '  Pin definitions'-------------------------------------------------------------------- _SPI_SRAM_DIR_CFG       long    %00000010_00000000_00001011_00000001 ' start direction for SPI pins_SPI_SEL_CLK            long    %00000000_00000000_00000001_00000000 ' pin 8_SPI_SEL_CLK_MASK       long    %11111111_11111111_11111110_11111111 ' masked_SPI_SEL_CLR            long    %00000010_00000000_00000000_00000000 ' pin 25_SPI_SEL_CLR_MASK       long    %11111101_11111111_11111111_11111111 ' masked                     _SPI_MOSI               long    %00000000_00000000_00000010_00000000 ' pin 9                   _SPI_MOSI_MASK          long    %11111111_11111111_11111101_11111111 ' masked _SPI_MISO               long    %00000000_00000000_00000100_00000000 ' pin 10_SPI_SCK                long    %00000000_00000000_00001000_00000000 ' pin 11_SPI_SCK_MASK           long    %11111111_11111111_11110111_11111111 ' masked '-------------------------------------------------------------------- '  SD variables'-------------------------------------------------------------------- _SD_Channel                     long 5_SD_RESPONSE_LIMIT              long 256             _SD_POWERUP_LIMIT               long 256_SD_RETRIEVE_SECTOR_LIMIT       long 4096 ' maximum number of iterations for SD to retrieve a requested sector/block_SD_WRITE_SECTOR_LIMIT          long 128 ' maximum number of iterations for SD to write a requested sector/block_SD_GO_IDLE_STATE               long $40 ' resets the SD card, places it into SPI mode, idle                            _SD_EXIT_IDLE_STATE             long $41 ' takes SD out of idle state ready for commands   _SD_APP_CMD                     long $77 ' makes sure card is in SD mode                   _SD_SEND_OP_CMD                 long $69 ' makes sure card is in SD mode                   _SD_READ_SINGLE_BLOCK           long $51 ' reads a single block (usually a 512 byte sector) at byte address sent in command address_SD_WRITE_BLOCK                 long $58 ' write a single block (usually a 512 byte sector) at byte address sent in command address                                 _SECTOR_SIZE                    long 9 ' in bit shift, the result should always be 512 for SD cards_MAX_SECTORS_BUFFER             long 1 ' number of sectors buffer can hold, make larger if needed                                                                                          bPtr                            long 0pPtr                            long 0fatPar                          long 0sectBuffer                      long 0'-------------------------------------------------------------------- '  variables'-------------------------------------------------------------------- _wrCmd                  long    %00000010_0000000000000000    '$2FFFF_rdCmd                  long    %00000011_0000000000000000    '$3FFFF   global_params           long    0nbytes                  long    0parResult               long    0tmp_ptr                 long    0   resultValue             long    0  ' value to put results inintResult               long    0  ' flag to drive writing result into shared memoryarg0                    long    0  ' caller's routines arguments     arg1                    long    0arg2                    long    0{{                    ______________________________________________________________________________________________________________________________|                                                   TERMS OF USE: MIT License                                                  |                                                            |______________________________________________________________________________________________________________________________||Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    |     |files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    ||modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software||is furnished to do so, subject to the following conditions:                                                                   ||                                                                                                                              ||The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.||                                                                                                                              ||THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          ||WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         ||COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   ||ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         | ------------------------------------------------------------------------------------------------------------------------------ }}                             