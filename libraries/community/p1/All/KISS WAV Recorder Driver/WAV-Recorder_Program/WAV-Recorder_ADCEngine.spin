{{///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// WAV-Recorder Analog to Digital Converter Engine//// Author: Kwabena W. Agyeman// Updated: 7/9/2011// Designed For: P8X32A// Version: 1.1//// Copyright (c) 2011 Kwabena W. Agyeman// See end of file for terms of use.//// Update History://// v1.0 - Original release - 2/28/2010.// v1.1 - Merged object with recorder - 7/9/2011.//// For each included copy of this object only one spin interpreter should access it at a time.//// Nyamekye,//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Audio Circuit:////                            3.3V//                             |//                             C 1NF// ADC Pin In Number    -------|//                             | 0.1UF//                      100KOHM|---C-- Right In// ADC Pin Out Number   ---R---|//                             |//                             C 1NF//                             |//                            GND///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}OBJ  fat: "SD-MMC_FATEngine.spin"VAR  long inputValue, clocksPerSample  word dataBlock[512], callerPointer, callePointer, samplesPerSecond  byte stopedOrStarted, cogIdentificationPUB channelInput '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the current sample coming in to the audio channel. The value returned is a 16 bit signed extended number.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return inputValuePUB fileSampleRate '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the sample rate of the file being recorded.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return samplesPerSecondPUB fileSampleNumber '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the number of samples in the file being recorded.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return (((fat.fileSize - WAVFileHeaderSize) #> 0) >> 1)PUB stopRecordingWAVFile '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Stops recording a WAV file to the SD/MMC card.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  stopedOrStarted := truePUB startRecordingWAVFile(filePathName) '' 52 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Starts recording a WAV file to the SD/MMC card - will record up to arround ~2GBs of data. 16-Bit/1-Channel.'' //'' // FilePathName - A file system path string specifying the path of the WAV file to create and record to.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  result := \recordWAV(filePathName)  \fat.unmountPartitionPRI recordWAV(filePathName) ' 48 Stack Longs  ifnot(fat.partitionMounted)    fat.mountPartition(0)  fat.openFile(fat.newFile(filePathName), "W")  fat.writeData(@WAVFileHeaderData, WAVFileHeaderSize)  stopedOrStarted := false  callerPointer := callePointer  repeat until(stopedOrStarted or (fat.fileSize => posx))    repeat while(callerPointer == callePointer)    fat.writeData(@dataBlock[256 & callerPointer], 512)    not callerPointer  fat.fileSeek(4)  fat.writeLong(fat.fileSize - 8)  fat.fileSeek(40)  fat.writeLong(fat.fileSize - WAVFileHeaderSize)PUB ADCEngineStart(pinInNumber, pinOutNumber, sampleRate) '' 9 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Starts up the ADC driver running on a cog.'' //'' // Returns true on success or false.'' //'' // PinInNumber - Pin used to record audio according to the converter circuit. Input pin.'' // PinOutNumber - Pin used to record audio according to the converter circuit. Feedback pin.'' // SampleRate - Sample rate to record audio at. Between 1 Hz and 44,100 Hz. 22,050 Hz recommended.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  ADCEngineStop  if(chipver == 1)    clocksPerSample := (clkfreq / (samplesPerSecond := ((sampleRate <# 44_100) #> 1)))    bytemove((@WAVFileHeaderData + 24), @samplesPerSecond, 2)    sampleRate := (samplesPerSecond << 1)    bytemove((@WAVFileHeaderData + 28), @sampleRate, 4)    counterSetup := (constant(%01001 << 26) + ((pinOutNumber & $1F) << 9) + (pinInNumber & $1F))    outputMask := (|<pinOutNumber)    inputValueAddress := @inputValue    clocksPerSampleAddress := @clocksPerSample    dataBlockAddress := @dataBlock    callePointerAddress := @callePointer    cogIdentification := cognew(@initialization, 0)    result or= ++cogIdentificationPUB ADCEngineStop '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Shuts down the ADC driver running on a cog.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if(cogIdentification)    cogstop(-1 + cogIdentification~)PUB FATEngineStart(DOPin, CLKPin, DIPin, CSPin, WPPin, CDPin, RTCReserved1, RTCReserved2, RTCReserved3) '' 18 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Starts up the SDC driver running on a cog and checks out a lock for the driver.'' //'' // This method should only be called once for any number of included versions of this object.'' //'' // This method causes all included versions of this object to need re-mounting when called.'' //'' // Returns true on success or false.'' //'' // DOPin - The SPI data out pin from the SD card. Between 0 and 31.'' // CLKPin - The SPI clock pin from the SD card. Between 0 and 31.'' // DIPin - The SPI data in pin from the SD card. Between 0 and 31.'' // CSPin - The SPI chip select pin from the SD card. Between 0 and 31.'' // WPPin - The SPI write protect pin from the SD card holder. Between 0 and 31. -1 if not installed.'' // CDPin - The SPI write protect pin from the SD card holder. Between 0 and 31. -1 if not installed.'' // RTCReserved1 - Reserved parameter 1 for RTC compatible driver versions. Pass -1.'' // RTCReserved2 - Reserved parameter 2 for RTC compatible driver versions. Pass -1.'' // RTCReserved3 - Reserved parameter 3 for RTC compatible driver versions. Pass -1.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  return fat.FATEngineStart(DOPin, CLKPin, DIPin, CSPin, WPPin, CDPin, RTCReserved1, RTCReserved2, RTCReserved3)PUB FATEngineStop '' 6 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Shuts down the SDC driver running on a cog and returns the lock used by the driver.'' //'' // This method should only be called once for any number of included versions of this object.'' //'' // This method causes all included versions of this object to need re-mounting when called.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  fat.FATEngineStopDAT' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       ADC Driver' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        org     0' //////////////////////Initialization/////////////////////////////////////////////////////////////////////////////////////////initialization          mov     ctra,            counterSetup               ' Setup counter I/O pins.                        mov     frqa,            #1                         '                        mov     dira,            outputMask                 '                        mov     recorderPointer, dataBlockAddress           '                        rdlong  recorderRate,    clocksPerSampleAddress     ' Setup timing.                        mov     timeCounter,     recorderRate               '                        add     timeCounter,     cnt                        '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Recorder' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////outerLoop               mov     counter,         #256                       ' 512 Bytes / 16 Bits / 1 Channel = 256 Samples.' //////////////////////Inner Loop/////////////////////////////////////////////////////////////////////////////////////////////innerLoop               waitcnt timeCounter,     recorderRate               ' Wait until next sample input period.                        mov     sampleBuffer,    phsa                       ' Get sample.                        sub     sampleBuffer,    sampleDelta                '                        add     sampleDelta,     sampleBuffer               '                        add     sampleAverage,   sampleBuffer               ' Average sample.                        shr     sampleAverage,   #1                         '                        mov     sampleBuffer,    sampleAverage              '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Scale Value' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        mov     mathBuffer,      #1                         ' Preform ((((sample << 32) / maxPHSA) + 1) >> 16)                            mov     mathCounter,     #32                        'scaleLoop               shl     sampleBuffer,    #1                         ' Remove sigma delta sample rate effect.                        cmpsub  sampleBuffer,    recorderRate wc            '                        rcl     mathBuffer,      #1                         '                        djnz    mathCounter,     #scaleLoop                 '                        shr     mathBuffer,      #16                        ' Limit to 16 bit result only.                        mov     sampleBuffer,    mathBuffer                 '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Encode Update' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        max     sampleBuffer,    wordMax                    ' Limit data and update value in ram.                        sub     sampleBuffer,    wordAdjust                 '                        wrlong  sampleBuffer,    inputValueAddress          '                        wrword  sampleBuffer,    recorderPointer            ' Write to double buffer.                        add     recorderPointer, #2                         '                        rdlong  recorderRate,    clocksPerSampleAddress     ' Loop.                        djnz    counter,         #innerLoop                 '' //////////////////////Outer Loop/////////////////////////////////////////////////////////////////////////////////////////////                        rdword  buffer,          callePointerAddress wz     ' Switch data block pointer.                        sumz    buffer,          #1                         '                        wrword  buffer,          callePointerAddress        'if_nz                   mov     recorderPointer, dataBlockAddress           '                        jmp     #outerLoop                                  ' Loop.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Data' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////sampleDelta             long    0                                           ' Delta initialized to zero.sampleAverage           long    0                                           ' Moving average.wordMax                 long    $FF_FF                                      ' Edits word unsigned value.wordAdjust              long    $80_00                                      ' Edits word signed value.' //////////////////////Configuration Settings/////////////////////////////////////////////////////////////////////////////////counterSetup            long    0outputMask              long    0' //////////////////////Addresses//////////////////////////////////////////////////////////////////////////////////////////////inputValueAddress       long    0clocksPerSampleAddress  long    0dataBlockAddress        long    0callePointerAddress     long    0' //////////////////////Run Time Variables/////////////////////////////////////////////////////////////////////////////////////buffer                  res     1counter                 res     1recorderPointer         res     1recorderRate            res     1sampleBuffer            res     1timeCounter             res     1mathBuffer              res     1mathCounter             res     1' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        fit     496CON WAVFileHeaderSize = 44 ' DO NOT EDIT!DAT WAVFileHeaderData ' DO NOT EDIT!' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  byte byte "RIFF" ' "RIFF" chunk header.  byte long 0 ' "RIFF" chunk size = (fileSize - 8). Offset 4.  byte byte "WAVE" ' File type.  byte byte "fmt " ' "fmt " chunk header.  byte long 16 ' "fmt " chunk size.  byte word 1 ' Audio format.  byte word 1 ' Nuber of channels.  byte long 0 ' Sample rate.EDITED by setup function!  byte long 0 ' Byte rate. EDITED by setup function!  byte word 2 ' Block align.  byte word 16 ' Bits per sample.  byte byte "data" ' "data" chunk header.  byte long 0 ' "data" chunk size = (fileSize - 44). Offset 40.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////{{/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                  TERMS OF USE: MIT License///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the// Software is furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the// Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}