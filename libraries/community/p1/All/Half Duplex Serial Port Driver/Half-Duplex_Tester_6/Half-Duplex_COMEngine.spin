{{///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Half-Duplex Communications Engine//// Author: Kwabena W. Agyeman// Updated: 8/31/2011// Designed For: P8X32A// Version: 1.4//// Copyright (c) 2011 Kwabena W. Agyeman// See end of file for terms of use.//// Update History://// v1.0 - Original release - 9/28/2009.// v1.1 - Updated comments and improved code readability and added support for parity bits - 12/7/2009.// v1.2 - Added support for variable pin assignments and variable stop bits - 3/12/2010.// v1.3 - Removed unneeded features and streamlined the object for easy use - 7/27/2010.// v1.4 - Rebuilt the driver interface - 8/31/2011.//// For each included copy of this object only one spin interpreter should access it at a time.//// Nyamekye,//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Serial Circuit://// Transmitter Pin Number --- Receiving Device Pin//// Receiver Pin Number --- Transmitting Device Pin///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}CON  #0, Null, {    } Start_Of_Heading, Start_Of_Text, End_Of_Text, End_Of_Transmission, {    } Enquiry, Acknowledge, {    } Bell, Backspace, Horizontal_Tab, Line_Feed, Vertical_Tab, Form_Feed, Carriage_Return, {    } Shift_Out, Shift_In, Data_Link_Escape, {    } Device_Control_1, Device_Control_2, Device_Control_3, Device_Control_4, {    } Negative_Aknowledge, Synchronous_Idle, End_Of_Transmission_Block, Cancel, End_Of_Medium, Substitute, Escape, {    } File_Seperator, Group_Seperator, Record_Seperator, Unit_Seperator  #17, XON, #19, XOFF  #34, Quotation_Marks, #127, DeleteVAR  long usedNumber, baudNumber, RXPin, TXPinPUB readByte '' 10 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns a byte from the serial line. May wait to receive the byte.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  readData(@result, 1)PUB readShort '' 10 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns a short from the serial line. May wait to receive the short.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  readData(@result, 2)PUB readLong '' 10 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns a long from the serial line. May wait to receive the long.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  readData(@result, 4)PUB readString(stringPointer, maximumStringLength) '' 12 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns a string from the serial line. May wait to receive the string.'' //'' // This method will stop reading when line feed (ASCII 10) is found - it will be included within the string.'' //'' // This method will stop reading when carriage return (ASCII 13) is found - it will be included within the string.'' //'' // StringPointer - A pointer to a string to read to from the serial line.'' // MaximumStringLength - The maximum read string length. Including the null terminating character.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if(stringPointer and (maximumStringLength > 0))    result := stringPointer    bytefill(stringPointer--, 0, maximumStringLength--)    repeat while(maximumStringLength--)      ifnot( readData(++stringPointer, 1) and byte[stringPointer] and {           } (byte[stringPointer] <> 10) and (byte[stringPointer] <> 13) )        quitPUB writeByte(value) '' 11 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Writes a byte out to be transmitted by the serial line. May wait to transmit the byte.'' //'' // Value - A byte.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  writeData(@value, 1)PUB writeShort(value) '' 11 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Writes a short out to be transmitted by the serial line. May wait to transmit the short.'' //'' // Value - A short.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  writeData(@value, 2)PUB writeLong(value) '' 11 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Writes a long out to be transmitted by the serial line. May wait to transmit the long.'' //'' // Value - A long.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  writeData(@value, 4)PUB writeString(stringPointer) '' 11 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Writes a string out to be transmitted by the serial line. May wait to transmit the string.'' //'' // Value - A string.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  writeData(stringPointer, strsize(stringPointer))PUB readData(addressToPut, count) | time, accumulator '' 7 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Reads data from the serial line. Returns the amount of data read from the serial line.'' //'' // AddressToPut - A pointer to the start of a data buffer to fill from the serial line.'' // Count - The amount of data to read from the serial line. The data buffer must be at least this large.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if((!RXPin) and usedNumber)    accumulator := addressToPut    repeat count      waitpeq(0, |<RXPin, 0)      time := ((baudNumber >> 1) + cnt)      repeat 9        waitcnt(time += baudNumber)        result := ((result -> 1) | ina[RXPin])      byte[addressToPut++] := (result >> 24)    return (addressToPut - accumulator)PUB writeData(addressToGet, count) | time, accumulator '' 7 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Writes data to the serial line. Returns the amount of data written to the serial line.'' //'' // AddressToPut - A pointer to the start of a data buffer to write to the serial line.'' // Count - The amount of data to write to the serial line. The data buffer must be at least this large.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if((!TXPin) and usedNumber)    accumulator := addressToGet    repeat count      result := ((byte[addressToGet++] | $7F_FF_FF_00) << 1)      time := cnt      repeat 10        outa[TXPin] := result        result >>= 1        waitcnt(time += baudNumber)    return (addressToGet - accumulator)PUB COMEngineStart(receiverPin, transmitterPin, baudRate) '' 9 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Changes and drives the Serial Circuit pins.'' //'' // Returns true on success and false on failure.'' //'' // ReceiverPin - Pin to use to receive data on. This line is driven by the interface chip. -1 to disable.'' // TransmitterPin - Pin to use to transmit data on. This line is driven by the propeller chip. -1 to disable.                                                                                                                                                                   ¦'' // BaudRate - The baud rate to transmit and receive at. Between 1 BPS and 19.2K BPS @ 96 MHz.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  COMEngineStop  usedNumber := true  baudNumber := (clkfreq / ((baudRate <# (clkfreq / constant(96_000_000 / 19_200))) #> 1))  RXPin := receiverPin  TXPin := transmitterPin  if(!RXPin)    dira[RXPin] := outa[RXPin] := 0  if(!TXPin)    dira[TXPin] := outa[TXPin] := 1  return (chipver == 1)PUB COMEngineStop '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Releases the pins used by the driver.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if((!TXPin) and (usedNumber~))    outa[TXPin] := dira[TXPin] := 0{{/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                  TERMS OF USE: MIT License///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the// Software is furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the// Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}