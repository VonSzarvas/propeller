{{///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// PWM1C Proportional Integral Derivative Engine//// Author: Kwabena W. Agyeman// Updated: 10/15/2010// Designed For: P8X32A// Version: 1.0//// Copyright (c) 2010 Kwabena W. Agyeman// See end of file for terms of use.//// Update History://// v1.0 - Original release - 10/15/2010.//// For each included copy of this object only one spin interpreter should acess it at a time.//// Nyamekye,//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Feedback Circuit://// Motor Left - To H-Bridge, driven by the propeller chip.//// Motor Right - To H-Bridge, driven by the propeller chip.//// Encoder Left - From the quadrature encoder, driven by the encoder.//// Encoder Right - From the quadrature encoder, driven by the encoder.///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}VAR  long cogNumber, positionMeasurement, deltaPositionMeasurement, speedTargetPUB quadraturePosition(deltaPosition) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Returns the delta or absolute position of the quadrature encoder in ticks.'' //'' // DeltaPosition - True to get the delta position since the last call. False to get the absolute position since last call.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  ifnot(deltaPosition)    return positionMeasurement  deltaPosition := positionMeasurement  result := deltaPosition - deltaPositionMeasurement  deltaPositionMeasurement := deltaPositionPUB quadratureSpeed(targetSpeed) '' 4 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Drives the quadrature encoder at a target speed using proportional, integral, and derivative control.'' //'' // TargetSpeed - The target speed in ticks per second. The target speed should be reachable by the system.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  speedTarget := targetSpeedPUB PIDEngineStart(motorLeft, motorRight, encoderLeft, encoderRight, PGain, IGain, DGain) '' 13 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Starts up the PID driver running on a cog.'' //'' // Returns true on success and false on failure.'' //'' // MotorLeft - The left drive pin of the h-bridge. -1 to disable output.'' // MotorRight - The right drive pin of the h-bridge. -1 to disable output.'' // EncoderLeft - The left leading signal pin of a quadrature encoder. -1 to disable input.'' // EncoderRight - The right leading signal pin of a quadrature encoder. -1 to disable input.'' // PGain - Power of two gain for the proportional drive. (0 to 31). Where zero disables the proportional factor.'' // IGain - Power of two gain for the integral drive. (0 to 31). Where zero disables the integral factor.'' // DGain - Power of two gain for the derivative drive. (0 to 31). Where zero disables the derivative factor.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  PIDEngineStop  if(chipver == 1)    leftEncoderPin := ((|<((encoderLeft <# 31) #> 0)) & (encoderLeft <> -1))    rightEncoderPin := ((|<((encoderRight <# 31) #> 0)) & (encoderRight <> -1))    encoderLeft := ((motorLeft <# 31) #> 0)    encoderRight := ((motorRight <# 31) #> 0)    leftDrivePin := ((|<encoderLeft) & (motorLeft <> -1))    rightDrivePin := ((|<encoderRight) & (motorRight <> -1))    leftCounterSetup := (constant(%0_0100 << 26) | encoderLeft)    rightCounterSetup := (constant(%0_0100 << 26) | encoderRight)    proportionalGain := (31 - ((PGain <# 31) #> 0))    integralGain := (31 - ((IGain <# 31) #> 0))    derivativeGain := (31 - ((DGain <# 31) #> 0))    positionAddress := @positionMeasurement    cogNumber := cognew(@initialization[0], @speedTarget[0])    result or= ++cogNumberPUB PIDEngineStop '' 3 Stack Longs'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'' // Shuts down the PID driver running on a cog.'' ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  if(cogNumber)    cogstop(-1 + cogNumber~)DAT' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       PID Driver' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        org     0' //////////////////////Initialization/////////////////////////////////////////////////////////////////////////////////////////initialization          mov     frqa,             #1                       ' Setup counter modules.                        mov     frqb,             #1                       '                        mov     ctra,             leftCounterSetup         '                        mov     ctrb,             rightCounterSetup        '                        or      dira,             leftDrivePin             ' Setup outputs.                        or      dira,             rightDrivePin            '                        mov     counter,          deltaTime                ' Setup sample time.                        add     counter,          cnt                      '' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Sync' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////loop                    waitcnt counter,          deltaTime                ' Wait until sample time.' //////////////////////Position Input/////////////////////////////////////////////////////////////////////////////////////////                        mov     buffer,           ina                      ' Sample left and right inputs.                        test    buffer,           leftEncoderPin wc        '                        test    buffer,           rightEncoderPin wz       '                        muxc    encoderCurrent,   #2                       ' Store left and right inputs.                        muxnz   encoderCurrent,   #1                       'initializeOnce          mov     encoderPrevious,  encoderCurrent           ' Initializes previous state once.                        mov     initializeOnce,   #0                       '                        cmp     encoderPrevious,  encoderCurrent wz        ' Update current state.if_nz                   rev     encoderPrevious,  #30                      'if_nz                   xor     encoderPrevious,  encoderCurrent           'if_nz                   cmpsub  encoderPrevious,  #2 wc, nr                'if_nz                   sumc    encoderPosition,  #1                       '                        wrlong  encoderPosition,  positionAddress          '                        mov     encoderPrevious,  encoderCurrent           ' Update previous state.' //////////////////////Speed Input////////////////////////////////////////////////////////////////////////////////////////////                        muxc    divideSign,       instructionMask          ' Flip the sign if negative.                        rdlong  buffer,           #0                       ' Check if a second has passed.                        cmpsub  buffer,           speedCounter wc, nr      'if_nz_or_nc             mov     speedBuffer,      speedCounter             ' Transfer difference.if_nz_or_nc             mov     speedCounter,     #0                       'if_z_and_c              jmp     #divideSkip                                '                        mov     averageCounter,   speedBuffer              ' Setup decay time for average.                        add     averageCounter,   deltaTime                '                        mov     divideBuffer,     #0                       ' Setup to divide. Buffer has clock frequency.                        mov     divideCounter,    #32                      'divideStart             shr     speedBuffer,      #1 wc, wz                ' Start divide.                        rcr     divideBuffer,     #1                       'if_nz                   djnz    divideCounter,    #divideStart             'divideFinish            cmpsub  buffer,           divideBuffer wc          ' Finish divide.                        rcl     speedBuffer,      #1                       '                        shr     divideBuffer,     #1                       '                        djnz    divideCounter,    #divideFinish            'divideSign              mov     speedBuffer,      speedBuffer              ' Flip the sign if negative.                        add     averageBuffer,    speedBuffer              ' Compute average.                        sar     averageBuffer,    #1                       'divideSkip              cmp     averageCounter,   speedCounter wc, wz      ' Decay average on slow down.if_nc_and_nz            jmp     #divideIncrement                           '                        abs     averageBuffer,    averageBuffer wc         '                        cmpsub  averageBuffer,    #1                       '                        negc    averageBuffer,    averageBuffer            'divideIncrement         add     speedCounter,     deltaTime                ' Increment ticks.' //////////////////////Feedback///////////////////////////////////////////////////////////////////////////////////////////////                        rdlong  PIDCurrentError,  par                      ' Update current error.                        sub     PIDCurrentError,  averageBuffer            '                        maxs    PIDCurrentError,  PIDValueMax              '                        mins    PIDCurrentError,  PIDValueMin              '                        add     PIDCounter,       PIDCurrentError          ' Compute I.                        maxs    PIDCounter,       PIDValueMax              '                        mins    PIDCounter,       PIDValueMin              '                        mov     PIDBuffer,        PIDCounter               '                        sar     PIDBuffer,        integralGain             '                        mov     buffer,           PIDCurrentError          ' Compute D.                        sub     buffer,           PIDPreviousError         '                        sar     buffer,           derivativeGain           '                        add     PIDBuffer,        buffer                   '                        mov     PIDPreviousError, PIDCurrentError          ' Update error.                        sar     PIDCurrentError,  proportionalGain         ' Compute P.                        add     PIDBuffer,        PIDCurrentError          '' //////////////////////Output/////////////////////////////////////////////////////////////////////////////////////////////////                        neg     phsa,             PIDBuffer                ' Drive forwards or backwards.                        mov     phsb,             PIDBuffer                '' //////////////////////Loop///////////////////////////////////////////////////////////////////////////////////////////////////                        jmp     #loop                                      ' Repeat.' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'                       Data' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////encoderCurrent          long    0encoderPosition         long    0speedBuffer             long    0speedCounter            long    0averageBuffer           long    0averageCounter          long    0PIDPreviousError        long    0PIDCounter              long    0' //////////////////////Constants//////////////////////////////////////////////////////////////////////////////////////////////deltaTime               long    800instructionMask         long    %000001_0000_0000_000000000_000000000PIDValueMax             long    536_870_911PIDValueMin             long    -536_870_911' //////////////////////Configuration Settings/////////////////////////////////////////////////////////////////////////////////leftCounterSetup        long    0rightCounterSetup       long    0proportionalGain        long    0integralGain            long    0derivativeGain          long    0' //////////////////////Pin Masks//////////////////////////////////////////////////////////////////////////////////////////////leftEncoderPin          long    0rightEncoderPin         long    0leftDrivePin            long    0rightDrivePin           long    0' //////////////////////Addresses//////////////////////////////////////////////////////////////////////////////////////////////positionAddress         long    0' //////////////////////Run Time Variables/////////////////////////////////////////////////////////////////////////////////////buffer                  res     1counter                 res     1divideBuffer            res     1divideCounter           res     1' //////////////////////Measurement Variables//////////////////////////////////////////////////////////////////////////////////encoderSpeed            res     1encoderPrevious         res     1' //////////////////////PID Variables//////////////////////////////////////////////////////////////////////////////////////////PIDCurrentError         res     1PIDBuffer               res     1' /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                        fit     496{{/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                  TERMS OF USE: MIT License///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation// files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the// Software is furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the// Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}}